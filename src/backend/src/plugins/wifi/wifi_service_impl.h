// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/master/protos/wifi/wifi.proto)

#include "wifi/wifi.grpc.pb.h"
#include "plugins/wifi/wifi.h"

#include "log.h"
#include <atomic>
#include <cmath>
#include <future>
#include <limits>
#include <memory>
#include <sstream>
#include <vector>

namespace mavsdk {
namespace backend {

template<typename Wifi = Wifi>
class WifiServiceImpl final : public rpc::wifi::WifiService::Service {
public:
    WifiServiceImpl(Wifi& wifi) : _wifi(wifi) {}

    template<typename ResponseType>
    void fillResponseWithResult(ResponseType* response, mavsdk::Wifi::Result& result) const
    {
        auto rpc_result = translateToRpcResult(result);

        auto* rpc_wifi_result = new rpc::wifi::WifiResult();
        rpc_wifi_result->set_result(rpc_result);
        std::stringstream ss;
        ss << result;
        rpc_wifi_result->set_result_str(ss.str());

        response->set_allocated_wifi_result(rpc_wifi_result);
    }

    static rpc::wifi::Mode translateToRpcMode(const mavsdk::Wifi::Mode& mode)
    {
        switch (mode) {
            default:
                LogErr() << "Unknown mode enum value: " << static_cast<int>(mode);
            // FALLTHROUGH
            case mavsdk::Wifi::Mode::Undefined:
                return rpc::wifi::MODE_UNDEFINED;
            case mavsdk::Wifi::Mode::AccessPoint:
                return rpc::wifi::MODE_ACCESS_POINT;
            case mavsdk::Wifi::Mode::Station:
                return rpc::wifi::MODE_STATION;
        }
    }

    static mavsdk::Wifi::Mode translateFromRpcMode(const rpc::wifi::Mode mode)
    {
        switch (mode) {
            default:
                LogErr() << "Unknown mode enum value: " << static_cast<int>(mode);
            // FALLTHROUGH
            case rpc::wifi::MODE_UNDEFINED:
                return mavsdk::Wifi::Mode::Undefined;
            case rpc::wifi::MODE_ACCESS_POINT:
                return mavsdk::Wifi::Mode::AccessPoint;
            case rpc::wifi::MODE_STATION:
                return mavsdk::Wifi::Mode::Station;
        }
    }

    static std::unique_ptr<rpc::wifi::AccessPointConfiguration>
    translateToRpcAccessPointConfiguration(
        const mavsdk::Wifi::AccessPointConfiguration& access_point_configuration)
    {
        std::unique_ptr<rpc::wifi::AccessPointConfiguration> rpc_obj(
            new rpc::wifi::AccessPointConfiguration());

        rpc_obj->set_ssid(access_point_configuration.ssid);

        rpc_obj->set_password(access_point_configuration.password);

        rpc_obj->set_mode(translateToRpcMode(access_point_configuration.mode));

        return rpc_obj;
    }

    static mavsdk::Wifi::AccessPointConfiguration translateFromRpcAccessPointConfiguration(
        const rpc::wifi::AccessPointConfiguration& access_point_configuration)
    {
        mavsdk::Wifi::AccessPointConfiguration obj;

        obj.ssid = access_point_configuration.ssid();

        obj.password = access_point_configuration.password();

        obj.mode = translateFromRpcMode(access_point_configuration.mode());

        return obj;
    }

    static rpc::wifi::WifiResult::Result translateToRpcResult(const mavsdk::Wifi::Result& result)
    {
        switch (result) {
            default:
                LogErr() << "Unknown result enum value: " << static_cast<int>(result);
            // FALLTHROUGH
            case mavsdk::Wifi::Result::Unknown:
                return rpc::wifi::WifiResult_Result_RESULT_UNKNOWN;
            case mavsdk::Wifi::Result::Success:
                return rpc::wifi::WifiResult_Result_RESULT_SUCCESS;
            case mavsdk::Wifi::Result::Rejected:
                return rpc::wifi::WifiResult_Result_RESULT_REJECTED;
            case mavsdk::Wifi::Result::ModeError:
                return rpc::wifi::WifiResult_Result_RESULT_MODE_ERROR;
            case mavsdk::Wifi::Result::SsidError:
                return rpc::wifi::WifiResult_Result_RESULT_SSID_ERROR;
            case mavsdk::Wifi::Result::PasswordError:
                return rpc::wifi::WifiResult_Result_RESULT_PASSWORD_ERROR;
            case mavsdk::Wifi::Result::Timeout:
                return rpc::wifi::WifiResult_Result_RESULT_TIMEOUT;
        }
    }

    static mavsdk::Wifi::Result translateFromRpcResult(const rpc::wifi::WifiResult::Result result)
    {
        switch (result) {
            default:
                LogErr() << "Unknown result enum value: " << static_cast<int>(result);
            // FALLTHROUGH
            case rpc::wifi::WifiResult_Result_RESULT_UNKNOWN:
                return mavsdk::Wifi::Result::Unknown;
            case rpc::wifi::WifiResult_Result_RESULT_SUCCESS:
                return mavsdk::Wifi::Result::Success;
            case rpc::wifi::WifiResult_Result_RESULT_REJECTED:
                return mavsdk::Wifi::Result::Rejected;
            case rpc::wifi::WifiResult_Result_RESULT_MODE_ERROR:
                return mavsdk::Wifi::Result::ModeError;
            case rpc::wifi::WifiResult_Result_RESULT_SSID_ERROR:
                return mavsdk::Wifi::Result::SsidError;
            case rpc::wifi::WifiResult_Result_RESULT_PASSWORD_ERROR:
                return mavsdk::Wifi::Result::PasswordError;
            case rpc::wifi::WifiResult_Result_RESULT_TIMEOUT:
                return mavsdk::Wifi::Result::Timeout;
        }
    }

    grpc::Status GetAccessPointConfiguration(
        grpc::ServerContext* /* context */,
        const rpc::wifi::GetAccessPointConfigurationRequest* /* request */,
        rpc::wifi::GetAccessPointConfigurationResponse* response) override
    {
        auto result = _wifi.get_access_point_configuration();

        if (response != nullptr) {
            fillResponseWithResult(response, result.first);
            response->set_allocated_configuration(
                translateToRpcAccessPointConfiguration(result.second).release());
        }

        return grpc::Status::OK;
    }

    grpc::Status SetAccessPointConfiguration(
        grpc::ServerContext* /* context */,
        const rpc::wifi::SetAccessPointConfigurationRequest* request,
        rpc::wifi::SetAccessPointConfigurationResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetAccessPointConfiguration sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _wifi.set_access_point_configuration(
            translateFromRpcAccessPointConfiguration(request->configuration()));

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    void stop()
    {
        _stopped.store(true);
        for (auto& prom : _stream_stop_promises) {
            if (auto handle = prom.lock()) {
                handle->set_value();
            }
        }
    }

private:
    void register_stream_stop_promise(std::weak_ptr<std::promise<void>> prom)
    {
        // If we have already stopped, set promise immediately and don't add it to list.
        if (_stopped.load()) {
            if (auto handle = prom.lock()) {
                handle->set_value();
            }
        } else {
            _stream_stop_promises.push_back(prom);
        }
    }

    void unregister_stream_stop_promise(std::shared_ptr<std::promise<void>> prom)
    {
        for (auto it = _stream_stop_promises.begin(); it != _stream_stop_promises.end();
             /* ++it */) {
            if (it->lock() == prom) {
                it = _stream_stop_promises.erase(it);
            } else {
                ++it;
            }
        }
    }

    Wifi& _wifi;
    std::atomic<bool> _stopped{false};
    std::vector<std::weak_ptr<std::promise<void>>> _stream_stop_promises{};
};

} // namespace backend
} // namespace mavsdk